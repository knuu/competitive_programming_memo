# B Counting of Trees

- 配点: 300
- 問題
    - 配列 $D = [d_1, d_2, \ldots, d_N]$ が与えられる
    - $D$ を頂点 1 からの距離とする木は何通りあるか？
- 解法
    - 条件: $d_1 = 0$ であり、距離が 0 である頂点は 1 つである必要がある
    - あとは距離 $k$ ごとに考えてよくて、(距離 k-1 の頂点数)^(距離 k の頂点数) を掛けていけばよい
    - 計算量は雑に見積もっても O(N log N)
- タグ: 数え上げ、グラフ、木
- 問題タイプ: 数え上げ

# C Swaps

- 配点: 600
- 解法
    - とりあえず A をソート済みにして、その順番で B も並べ替えておく
    - まず両方をソートしたときにできなければ No
    - そもそもソート済みにするための最小 swap は高々 N-1 回でできる
        - 巡回置換を考えれば、置換回数は N - (サイクルの数) なので、高々 N-1
        - なので、サイクルが 2 つ以上に分かれる場合は N-2 回でのソートが可能 => 答えは Yes
    - ソート済みの $As, Bs$ に対して、$As_{i} \le Bs_{i+1}$ となるような $i$ があれば、長さ N-1 のサイクルをそれ以下の長さのサイクルにできるか、2 つのサイクルに分解できる
    - 計算量はソートの O(N log N)
- タグ: 順列、グラフ
- 問題タイプ: シミュレーション、構築
- 類題
    - 最小回数は？
    - KUPC 2015 G ケンドー
        - 片方が昇順の場合でかつ隣どうしの swap の場合、条件を満たすような最小 swap 回数は？
        - 解法は大きい方から埋めていくだけ。O(N log N)

# D Shortest Path on a Line

- 配点: 600
- 解法
    - 最短経路という仮定を置くと、進んで戻るような枝は無視してよい
        - 戻るような経路がある場合、長さがそれ以下の経路を構成できるため仮定に矛盾
    - あとは DAG を探索するだけ
    - DAG を考えると、頂点 $i$ への最短距離は $i$ へはられている枝をすべて考えて最小のものを取ればよい
        - ただ、枝が O(M^2) 個あるので高速化が必要
    - ある範囲 $[L_i, R_i]$ において構築される枝は、$(L_i, L_i+1), (L_i, L_i+2), \ldots, (L_i, R_i)$ しか使われない
        - それ以外の枝を使うような最短経路がある場合、それ以下の最短経路を構成できる
        - しかもそれで更新される場合の最短距離は必ず $dist[L_i] + C_i$ になる
    - よって、std::multiset を使って、$dist[L_i] + C_i$ を $L_i$ のところで push して、$R_i$ のところで pop する
    - これを使って、各 $dist[i]$ で最小の値を取ればよいだけ
    - 計算量は O(N log N)
- タグ: グラフ、multiset、データ構造
- 問題タイプ: 最大・最小